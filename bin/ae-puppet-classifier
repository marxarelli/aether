#!/usr/bin/env ruby
#
# Classifies Puppet nodes based on the security group they're running in.
#

require 'optparse'

require 'rubygems'
require 'AWS'
require 'socket'
require 'observer'
require 'tempfile'
require 'yaml'

options = {}

OptionParser.new do |parser|
  parser.banner = "Usage: ae-puppet-classfifier [options] HOST"

  options[:access_key] = "/mnt/access.key"
  parser.on("-a", "--access-key FILE", "A file containing the AWS access key.") do |file|
    options[:access_key] = file
  end

  options[:secret_key] = "/mnt/secret.key"
  parser.on("-s", "--secret-key FILE", "A file containing the AWS secret key.") do |file|
    options[:secret_key] = file
  end

  options[:cache_file] = nil
  parser.on("-c", "--cache-file FILE", "A file for caching instance data.") do |file|
    options[:cache_file] = file
  end

  options[:cache_life] = nil
  parser.on("-l", "--cache-life SECONDS", "The cache life in seconds.") do |seconds|
    options[:cache_life] = seconds.to_i
  end

  options[:verbose] = false
  parser.on("-v", "--verbose", "Describe what's going on.") do
    options[:verbose] = true
  end

  parser.on_tail("-h", "--help", "Show this message.") do
    puts parser
    exit
  end
end.parse!


module Aether
  class PuppetClassifier
    include Observable
    # Initializes a new classifier using the given EC2 connection as context.
    #
    def initialize(ec2, options = {})
      @ec2 = ec2
      @cache_file = options[:cache_file] || File.join(Dir.tmpdir, "ae-pc-instances.yml")
      @cache_life = options[:cache_life] || (4 * 60)
    end

    # Classifies the given host into a Puppet class and returns the YAML used
    # for configuration via +external_nodes+ in +puppet.conf+.
    #
    def classify(host)
      notify "classifying host", host

      normal_host = normalize_host(host)

      notify "normalized host", normal_host

      instance = instances[normal_host]

      notify(*(instance ? ["found instance", instance.instanceId] : ["no instance found"]))

      instance ? export(instance).to_yaml : ''
    end

    def verbose!
      self.add_observer(Notifier.new)
    end

    protected

    def notify(*args)
      changed
      notify_observers(*args)
    end

    private

    # Formulates a unique name for the given instance that we use on our
    # Aether network.
    #
    def aether_name(instance)
      "#{instance.group}-#{instance.instanceId[2,10]}"
    end

    # Build a corpus of data that the puppet manifests should have.
    #
    def export(instance)
      # Hyphens aren't allowed in class names, so replace them with underscores.
      classification = { 'classes' => [ instance.group.tr('-', '_') ] }

      parameters = {'aether_name' => aether_name(instance)}

      # Serialize all instances and group by sercurity group
      parameters[ec2_key('groups')] = instances.inject({}) do |hash, (k,i)|
        hash[i.group] ||= {}
        hash[i.group][aether_name(i)] = serialize(i)
        hash
      end

      parameters[ec2_key('instance')] = serialize(instance)

      classification['parameters'] = parameters

      classification
    end

    # Returns all instances, keyed by hostname, either from a serialized cache
    # or straight from AWS.
    #
    def instances
      File.open(@cache_file, File::RDWR|File::CREAT, 0600) do |f|
        # Be thread/process safe by grabbing a file mutex
        notify "locking cache file", @cache_file
        f.flock(File::LOCK_EX)

        # Is the cache new or too old?
        if f.stat.size == 0 or f.stat.mtime < (Time.now - @cache_life)
          notify "fetching and caching instances"
          f.write(load_instances.to_yaml)
        else
          notify "cache is new enough", f.stat.mtime
        end
      end

      @instances ||= YAML.load(File.open(@cache_file))
    end

    def ec2_key(key)
      key.to_s.gsub(/([a-z\d])([A-Z])/, '\1_\2').downcase
    end

    def load_instances
      @instances ||= @ec2.describe_instances.reservationSet.item.inject({}) do |i,set|
        instance = set.instancesSet.item[0]
        instance["group"] = set.groupSet.item[0].groupId
        i[within_aws? ? instance.privateDnsName : instance.dnsName] = instance
        i
      end
    end

    # Determines whether we're executing from inside AWS.
    #
    def within_aws?
      @aws_addr_info ||= Socket.getaddrinfo("169.254.169.254", 80, Socket::AF_INET)
      @aws_addr_info.first[2] == "instance-data.ec2.internal"
    rescue SocketError
      false
    end

    # Does a forward, then reverse, DNS lookup on the host.
    #
    def normalize_host(host)
      notify "performing reverse lookup", host

      Socket.getaddrinfo(host, nil, Socket::AF_INET).first[2]
    rescue SocketError => e
      raise e, "failed to resolve host `#{host}'"
    end

    # Serializes the given instance as output suitable for puppet.
    #
    def serialize(instance)
      instance.inject({}) do |hash, (k, v)|
        if v.is_a?(String)
          hash[ec2_key(k)] = v
        elsif k == 'placement'
          hash[ec2_key('zone')] = v.availabilityZone
        end
        hash
      end
    end
  end

  class Notifier
    def update(msg, *args)
      STDERR.puts msg + ': ' + args.join('; ')
    end
  end
end

ec2 = AWS::EC2::Base.new(:access_key_id => File.new(options[:access_key]).gets.chomp,
                         :secret_access_key => File.new(options[:secret_key]).gets.chomp)

pc = Aether::PuppetClassifier.new(ec2, options)
pc.verbose! if options[:verbose]

raise "You must specify a host" if ARGV.empty?

puts pc.classify(ARGV.first)
