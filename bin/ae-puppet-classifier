#!/usr/bin/env ruby
#
# Classifies Puppet nodes based on the security group they're running in.
#

require 'optparse'

require 'rubygems'
require 'AWS'
require 'socket'
require 'observer'
require 'yaml'

options = {}

OptionParser.new do |parser|
  parser.banner = "Usage: ae-puppet-classfifier [options] HOST"

  options[:access_key] = "/mnt/access.key"
  parser.on("-a", "--access-key FILE", "Use the access key stored here.") do |file|
    options[:access_key] = file
  end

  options[:secret_key] = "/mnt/secret.key"
  parser.on("-s", "--secret-key FILE", "Use the secret key stored here.") do |file|
    options[:secret_key] = file
  end

  options[:verbose] = false
  parser.on("-v", "--verbose", "Describe what's going on.") do
    options[:verbose] = true
  end

  parser.on_tail("-h", "--help", "Show this message.") do
    puts parser
    exit
  end
end.parse!


module Aether
  class PuppetClassifier
    include Observable
    # Initializes a new classifier using the given EC2 connection as context.
    #
    def initialize(ec2)
      @ec2 = ec2
    end

    # Classifies the given host into a Puppet class and returns the YAML used
    # for configuration via +external_nodes+ in +puppet.conf+.
    #
    def classify(host)
      notify "classifying host", host

      normal_host = normalize_host(host)

      notify "looking at instances"

      instance = instances.find do |i|
        (within_aws? ? i.privateDnsName : i.dnsName) == normal_host
      end

      notify "no instance found" unless instance

      build_yaml(instance ? instance.group : host)
    end

    def verbose!
      self.add_observer(Notifier.new)
    end

    protected

    def notify(*args)
      changed
      notify_observers(*args)
    end

    private

    def build_yaml(node)
      {'classes' => [node]}.to_yaml
    end

    def instances
      @ec2.describe_instances.reservationSet.item.map do |set|
        instance = set.instancesSet.item[0]
        instance["group"] = set.groupSet.item[0].groupId
        instance
      end
    end

    # Determines whether we're executing from inside AWS.
    #
    def within_aws?
      @aws_addr_info ||= Socket.getaddrinfo("169.254.169.254", 80, Socket::AF_INET)
      @aws_addr_info.first[2] == "instance-data.ec2.internal"
    rescue SocketError
      false
    end

    # Does a forward, then reverse, DNS lookup on the host.
    #
    def normalize_host(host)
      notify "performing reverse looking", host

      Socket.getaddrinfo(host, nil, Socket::AF_INET).first[2]
    rescue SocketError => e
      raise e, "failed to resolve host `#{host}'"
    end
  end

  class Notifier
    def update(msg, *args)
      puts msg + ': ' + args.join('; ')
    end
  end
end

ec2 = AWS::EC2::Base.new(:access_key_id => File.new(options[:access_key]).gets.chomp,
                         :secret_access_key => File.new(options[:secret_key]).gets.chomp)

pc = Aether::PuppetClassifier.new(ec2)
pc.verbose! if options[:verbose]

raise "You must specify a host" if ARGV.empty?

puts pc.classify(ARGV.first)
